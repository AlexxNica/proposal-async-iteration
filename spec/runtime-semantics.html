<emu-clause>
  <h1>Runtime Semantics: EvaluateBody</h1>
  <p>With parameters _functionObject_ and List _argumentsList_.</p>
  <emu-grammar>
    GeneratorBody : FunctionBody
  </emu-grammar>
  <emu-alg>
    1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).
    1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, `"%AsyncGeneratorPrototype%"`, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]] »).
    1. Perform ! AsyncGeneratorStart(_generator_, _FunctionBody_).
    1. Return Completion{[[type]]: ~return~, [[value]]: _generator_, [[target]]: ~empty~}.
  </emu-alg>
</emu-clause>

<emu-clause>
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>
    YieldExpression : `yield`
  </emu-grammar>
  <emu-alg>
    1. Let _resultObject_ be CreateIterResultObject(*undefined*, *false*).
    1. If ! GetGeneratorContextKind() is ~async~, then
      1. TODO: For consistency, should we await here?  Kinda silly, but...
      1. Return AsyncGeneratorYield(_resultObject_).
    1. Return GeneratorYield(_resultObject_).
  </emu-alg>
</emu-clause>

<emu-clause>
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>
    YieldExpression : `yield` AssignmentExpression
  </emu-grammar>
  <emu-alg>
    1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.
    1. Let _value_ be ? GetValue(_exprRef_).
    1. If ! GetGeneratorContextKind() is ~async~, then
      1. Let _value_ be ? AsyncFunctionAwait(_value_).
      1. Return AsyncGeneratorYield(CreateIterResultObject(_value_, *false*)).
    1. Return GeneratorYield(CreateIterResultObject(_value_, *false*)).
  </emu-alg>
</emu-clause>

<emu-clause>
  <h1>Runtime Semantics: Evaluation</h1>
  <emu-grammar>
    YieldExpression : `yield` `*` AssignmentExpression
  </emu-grammar>
  <emu-alg>
    1. Let _exprRef_ be the result of evaluating |AssignmentExpression|.
    1. Let _value_ be ? GetValue(_exprRef_).
    1. Let _iteratorKind_ be ! GetGeneratorContextKind().
    1. If _iteratorKind_ is ~async~, let _iterator_ be ? GetAsyncIterator(_value_).
    1. Else, let _iterator_ be ? GetIterator(_value_).
    1. Let _received_ be NormalCompletion(*undefined*).
    1. Repeat
      1. If _received_.[[type]] is ~normal~, then
        1. Let _innerResult_ be ? IteratorNext(_iterator_, _received_.[[value]]).
        1. If _iteratorKind_ is ~async~, then
          1. Let _innerResult_ be ? AsyncGeneratorAwaitResult(_innerResult_).
        1. Let _done_ be ? IteratorComplete(_innerResult_).
        1. If _done_ is *true*, then
          1. Return IteratorValue(_innerResult_).
        1. If _iteratorKind_ is ~async~, let _recieved_ be AsyncGeneratorYield(_innerResult_).
        1. Else, let _received_ be GeneratorYield(_innerResult_).
      1. Else if _received_.[[type]] is ~throw~, then
        1. Let _throw_ be ? GetMethod(_iterator_, `"throw"`).
        1. If _throw_ is not *undefined*, then
          1. Let _innerResult_ be ? Call(_throw_, _iterator_, « _received_.[[value]] »).
          1. If _iteratorKind_ is ~async~, then
            1. Let _innerResult_ be ? AsyncGeneratorAwaitResult(_innerResult_).
          1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.
          1. If Type(_innerResult_) is not Object, throw a *TypeError* exception.
          1. Let _done_ be ? IteratorComplete(_innerResult_).
          1. If _done_ is *true*, then
            1. Let _value_ be ? IteratorValue(_innerResult_).
            1. Return Completion{[[type]]: ~return~, [[value]]: _value_, [[target]]: ~empty~}.
          1. If _iteratorKind_ is ~async~, let _recieved_ be AsyncGeneratorYield(_innerResult_).
          1. Else, let _received_ be GeneratorYield(_innerResult_).
        1. Else,
          1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.
          1. Let _closeResult_ be ? IteratorClose(_iterator_, Completion{[[type]]: ~normal~, [[value]]: ~empty~, [[target]]: ~empty~}, _iteratorKind_).
          1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.
          1. Throw a *TypeError* exception.
      1. Else,
        1. Assert: _received_.[[type]] is ~return~.
        1. Let _return_ be ? GetMethod(_iterator_, `"return"`).
        1. If _return_ is *undefined*, return Completion(_received_).
        1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, « _received_.[[value]] »).
        1. If _iteratorKind_ is ~async~, then
          1. Let _innerResult_ be ? AsyncGeneratorAwaitResult(_innerResult_).
        1. If Type(_innerReturnResult_) is not Object, throw a *TypeError* exception.
        1. Let _done_ be ? IteratorComplete(_innerReturnResult_).
        1. If _done_ is *true*, then
          1. Let _value_ be ? IteratorValue(_innerReturnResult_).
          1. Return Completion{[[type]]: ~return~, [[value]]: _value_, [[target]]: ~empty~}.
        1. If _iteratorKind_ is ~async~, let _recieved_ be AsyncGeneratorYield(_innerResult_).
        1. Else, let _received_ be GeneratorYield(_innerResult_).
  </emu-alg>
</emu-clause>

<emu-clause>
  <h1>Runtime Semantics: LabelledEvaluation</h1>
  <emu-grammar>
    IterationStatement : `for` `await` `(` ForDeclaration `of` AssignmentExpression `)` Statement
  </emu-grammar>
  <emu-alg>
    1. Let _keyResult_ be the result of performing ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).
    1. Return ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~lexicalBinding~, _labelSet_, ~async~).
  </emu-alg>
</emu-clause>

<emu-clause>
  <h1>Runtime Semantics: ForIn/OfHeadEvaluation ( _TDZnames_, _expr_, _iterationKind_ )</h1>
  <p>The abstract operation ForIn/OfHeadEvaluation is called with arguments _TDZnames_, _expr_, _iterationKind_, and _async_. The value of _iterationKind_ is ~enumerate~, ~iterate~, or ~async-iterate~.</p>
  <emu-alg>
    1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
    1. If _TDZnames_ is not an empty List, then
      1. Assert: _TDZnames_ has no duplicate entries.
      1. Let _TDZ_ be NewDeclarativeEnvironment(_oldEnv_).
      1. Let _TDZEnvRec_ be _TDZ_'s EnvironmentRecord.
      1. For each string _name_ in _TDZnames_, do
        1. Let _status_ be _TDZEnvRec_.CreateMutableBinding(_name_, *false*).
        1. Assert: _status_ is never an abrupt completion.
      1. Set the running execution context's LexicalEnvironment to _TDZ_.
    1. Let _exprRef_ be the result of evaluating the production that is _expr_.
    1. Set the running execution context's LexicalEnvironment to _oldEnv_.
    1. Let _exprValue_ be ? GetValue(_exprRef_).
    1. If _iterationKind_ is ~enumerate~, then
      1. If _exprValue_.[[value]] is *null* or *undefined*, then
        1. Return Completion{[[type]]: ~break~, [[value]]: ~empty~, [[target]]: ~empty~}.
      1. Let _obj_ be ToObject(_exprValue_).
      1. Return ? _obj_.[[Enumerate]]().
    1. Else, if _iterationKind_ is ~async-iterate~, then
      1. Return ? GetAsyncIterator(_exprValue_).
    1. Else,
      1. Assert: _iterationKind_ is ~iterate~.
      1. Return ? GetIterator(_exprValue_).
  </emu-alg>
</emu-clause>

<emu-clause>
  <h1>Runtime Semantics: ForIn/OfBodyEvaluation ( _lhs_, _stmt_, _iterator_, _lhsKind_, _labelSet_, _iteratorKind_ )</h1>
  <p>The abstract operation ForIn/OfBodyEvaluation is called with arguments _lhs_, _stmt_, _iterator_, _lhsKind_, _labelSet_, and optional argument _iteratorKind_. The value of _lhsKind_ is either ~assignment~, ~varBinding~ or ~lexicalBinding~.  The value of _iteratorKind_ is either ~normal~ or ~async~.</p>
  <emu-alg>
    1. If _iteratorKind_ was not passed, let _iteratorKind_ be ~normal~.
    1. Let _oldEnv_ be the running execution context's LexicalEnvironment.
    1. Let _V_ be *undefined*.
    1. Let _destructuring_ be IsDestructuring of _lhs_.
    1. If _destructuring_ is *true* and if _lhsKind_ is ~assignment~, then
      1. Assert: _lhs_ is a |LeftHandSideExpression|.
      1. Let _assignmentPattern_ be the parse of the source text corresponding to _lhs_ using |AssignmentPattern| as the goal symbol.
    1. Repeat
      1. Let _nextResult_ be ? IteratorNext(_iterator_).
      1. If _iteratorKind_ is ~async~, then
        1. Let _nextResult_ be ? AsyncGeneratorAwaitResult(_nextResult_).
      1. Let _done_ be ? IteratorComplete(_iterator_).
      1. If _done_ is *true*, return NormalCompletion(_V_).
      1. Let _nextValue_ be ? IteratorValue(_nextResult_).
      1. If _lhsKind_ is either ~assignment~ or ~varBinding~, then
        1. If _destructuring_ is *false*, then
          1. Let _lhsRef_ be the result of evaluating _lhs_ (it may be evaluated repeatedly).
      1. Else,
        1. Assert: _lhsKind_ is ~lexicalBinding~.
        1. Assert: _lhs_ is a |ForDeclaration|.
        1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).
        1. Perform BindingInstantiation for _lhs_ passing _iterationEnv_ as the argument.
        1. Set the running execution context's LexicalEnvironment to _iterationEnv_.
        1. If _destructuring_ is *false*, then
          1. Assert: _lhs_ binds a single name.
          1. Let _lhsName_ be the sole element of BoundNames of _lhs_.
          1. Let _lhsRef_ be ResolveBinding(_lhsName_).
          1. Assert: _lhsRef_ is not an abrupt completion.
      1. If _destructuring_ is *false*, then
        1. If _lhsRef_ is an abrupt completion, then
          1. Let _status_ be _lhsRef_.
        1. Else if _lhsKind_ is ~lexicalBinding~, then
          1. Let _status_ be InitializeReferencedBinding(_lhsRef_, _nextValue_).
        1. Else,
          1. Let _status_ be PutValue(_lhsRef_, _nextValue_).
      1. Else,
        1. If _lhsKind_ is ~assignment~, then
          1. Let _status_ be the result of performing DestructuringAssignmentEvaluation of _assignmentPattern_ using _nextValue_ as the argument.
        1. Else if _lhsKind_ is ~varBinding~, then
          1. Assert: _lhs_ is a |ForBinding|.
          1. Let _status_ be the result of performing BindingInitialization for _lhs_ passing _nextValue_ and *undefined* as the arguments.
        1. Else,
          1. Assert: _lhsKind_ is ~lexicalBinding~.
          1. Assert: _lhs_ is a |ForDeclaration|.
          1. Let _status_ be the result of performing BindingInitialization for _lhs_ passing _nextValue_ and _iterationEnv_ as arguments.
      1. If _status_ is an abrupt completion, then
        1. Set the running execution context's LexicalEnvironment to _oldEnv_.
        1. Return ? IteratorClose(_iterator_, _status_, _iteratorKind_).
      1. Let _result_ be the result of evaluating _stmt_.
      1. Set the running execution context's LexicalEnvironment to _oldEnv_.
      1. If LoopContinues(_result_, _labelSet_) is *false*, return ? IteratorClose(_iterator_, UpdateEmpty(_result_, _V_), _iteratorKind_).
      1. If _result_.[[value]] is not ~empty~, let _V_ be _result_.[[value]].
  </emu-alg>
</emu-clause>
